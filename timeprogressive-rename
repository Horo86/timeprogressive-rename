#!/usr/bin/env python3
"""
timeprogressive-rename - Rename files with progressive numbering based on date

This script renames files with specified extensions by adding a prefix
and progressive numbering based on file creation (or modification) date.

Author: Horo86
License: MIT
"""

import os
import sys
import argparse
from pathlib import Path
from datetime import datetime
import tempfile


# ANSI color codes for terminal
class Colors:
    """Defines colors for terminal output"""
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'


def print_colored(text, color):
    """
    Print colored text to terminal
    
    Args:
        text (str): The text to print
        color (str): The color code to use
    """
    print(f"{color}{text}{Colors.ENDC}")


def get_file_creation_time(filepath):
    """
    Get file creation time, fall back to modification time if not available
    
    Args:
        filepath (Path): The file path
        
    Returns:
        float: Timestamp of file creation or modification
    """
    stat = filepath.stat()
    
    # Try to get creation time (available on some filesystems)
    try:
        # st_birthtime on some systems, st_ctime on ext4 (but it's change time, not creation)
        # On Linux ext4, we use st_mtime as reliable fallback
        if hasattr(stat, 'st_birthtime'):
            return stat.st_birthtime
        else:
            # On ext4 and many Linux filesystems, we use mtime (modification date)
            return stat.st_mtime
    except AttributeError:
        return stat.st_mtime


def find_files_by_extensions(directory, extensions):
    """
    Find all files with specified extensions in directory
    
    Args:
        directory (Path): The directory to search in
        extensions (list): List of extensions (without dot)
        
    Returns:
        list: List of Path objects for found files
    """
    files = []
    
    # Normalize extensions to lowercase for case-insensitive comparison
    extensions_lower = [ext.lower() for ext in extensions]
    
    # Iterate only over files in current directory (non-recursive)
    for item in directory.iterdir():
        if item.is_file():
            # Get extension without dot and in lowercase
            file_ext = item.suffix[1:].lower() if item.suffix else ''
            
            if file_ext in extensions_lower:
                files.append(item)
    
    return files


def sort_files_by_date(files):
    """
    Sort files by creation/modification date
    
    Args:
        files (list): List of Path objects
        
    Returns:
        list: List of tuples (Path, timestamp) sorted by timestamp
    """
    files_with_dates = []
    
    for file in files:
        timestamp = get_file_creation_time(file)
        files_with_dates.append((file, timestamp))
    
    # Sort by timestamp
    files_with_dates.sort(key=lambda x: x[1])
    
    return files_with_dates


def generate_new_names(files_with_dates, prefix):
    """
    Generate new names for files
    
    Args:
        files_with_dates (list): List of tuples (Path, timestamp)
        prefix (str): The prefix to use for new names
        
    Returns:
        list: List of tuples (original Path, new name, timestamp)
    """
    new_names = []
    
    for index, (file, timestamp) in enumerate(files_with_dates, start=1):
        # Generate progressive number with 3 digits
        number = f"{index:03d}"
        
        # Keep original extension
        extension = file.suffix
        
        # Create new name
        new_name = f"{prefix}_{number}{extension}"
        
        new_names.append((file, new_name, timestamp))
    
    return new_names


def show_preview(new_names, directory):
    """
    Show preview of rename operations (dry run)
    
    Args:
        new_names (list): List of tuples (original Path, new name, timestamp)
        directory (Path): The working directory
    """
    print_colored("\n" + "="*80, Colors.HEADER)
    print_colored("RENAME OPERATIONS PREVIEW", Colors.HEADER + Colors.BOLD)
    print_colored("="*80 + "\n", Colors.HEADER)
    
    print(f"{'No':<5} {'Creation/Modification Date':<22} {'Original Name':<25} {'→':<3} {'New Name':<25}")
    print("-" * 80)
    
    for index, (original_path, new_name, timestamp) in enumerate(new_names, start=1):
        date_str = datetime.fromtimestamp(timestamp).strftime('%Y-%m-%d %H:%M:%S')
        original_name = original_path.name
        
        # Use different colors for alternate rows to improve readability
        color = Colors.OKCYAN if index % 2 == 0 else Colors.OKBLUE
        print_colored(f"{index:<5} {date_str:<22} {original_name:<25} {'→':<3} {new_name:<25}", color)
    
    print("\n" + "-" * 80)
    print_colored(f"Total files to rename: {len(new_names)}", Colors.BOLD)
    print_colored("="*80 + "\n", Colors.HEADER)


def rename_files(new_names, directory):
    """
    Execute file renaming with conflict handling
    
    Args:
        new_names (list): List of tuples (original Path, new name, timestamp)
        directory (Path): The working directory
        
    Returns:
        tuple: (number of successfully renamed files, number of errors)
    """
    success_count = 0
    error_count = 0
    temp_renames = []  # Track temporary renames
    
    try:
        # Phase 1: Rename files with filename conflicts to temporary names
        for original_path, new_name, _ in new_names:
            new_path = directory / new_name
            
            # If new name exists and is different from original file, rename temporarily
            if new_path.exists() and new_path != original_path:
                temp_name = f".tmp_{original_path.name}_{os.getpid()}"
                temp_path = directory / temp_name
                new_path.rename(temp_path)
                temp_renames.append((temp_path, new_path))
        
        # Phase 2: Execute all main renames
        for original_path, new_name, _ in new_names:
            try:
                new_path = directory / new_name
                
                # If original file still exists (wasn't temporarily renamed)
                if original_path.exists():
                    original_path.rename(new_path)
                    success_count += 1
                    print_colored(f"✓ Renamed: {original_path.name} → {new_name}", Colors.OKGREEN)
                    
            except Exception as e:
                error_count += 1
                print_colored(f"✗ Error renaming {original_path.name}: {str(e)}", Colors.FAIL)
        
        # Phase 3: Rename temporary files to their final names
        for temp_path, final_path in temp_renames:
            try:
                if temp_path.exists():
                    temp_path.rename(final_path)
                    success_count += 1
                    print_colored(f"✓ Renamed: {temp_path.name} → {final_path.name}", Colors.OKGREEN)
            except Exception as e:
                error_count += 1
                print_colored(f"✗ Error renaming temporary file {temp_path.name}: {str(e)}", Colors.FAIL)
                
    except Exception as e:
        print_colored(f"\n✗ Error during rename: {str(e)}", Colors.FAIL)
        error_count += 1
    
    return success_count, error_count


def main():
    """Main script function"""
    
    # Configure argument parser
    parser = argparse.ArgumentParser(
        description='Rename files with progressive numbering based on creation/modification date',
        epilog='Example: timeprogressive-rename jpg jpeg png'
    )
    parser.add_argument(
        'extensions',
        nargs='+',
        help='File extensions to rename (without dot, e.g. jpg png)'
    )
    
    # Parse arguments
    args = parser.parse_args()
    
    # Current directory
    current_dir = Path.cwd()
    
    # Header
    print_colored("\n" + "="*80, Colors.HEADER)
    print_colored("TIME PROGRESSIVE RENAME", Colors.HEADER + Colors.BOLD)
    print_colored("="*80, Colors.HEADER)
    print(f"\nDirectory: {current_dir}")
    print(f"Extensions: {', '.join(args.extensions)}\n")
    
    # Find files
    print_colored("Searching for files...", Colors.OKCYAN)
    files = find_files_by_extensions(current_dir, args.extensions)
    
    if not files:
        print_colored(f"\n✗ No files found with specified extensions: {', '.join(args.extensions)}", 
                     Colors.WARNING)
        sys.exit(0)
    
    print_colored(f"✓ Found {len(files)} files", Colors.OKGREEN)
    
    # Ask for prefix
    print()
    prefix = input(f"{Colors.BOLD}Enter the prefix to use: {Colors.ENDC}").strip()
    
    if not prefix:
        print_colored("\n✗ Invalid prefix. Operation cancelled.", Colors.FAIL)
        sys.exit(1)
    
    # Sort files by date
    files_with_dates = sort_files_by_date(files)
    
    # Generate new names
    new_names = generate_new_names(files_with_dates, prefix)
    
    # Show preview
    show_preview(new_names, current_dir)
    
    # Ask for confirmation
    while True:
        confirm = input(f"{Colors.BOLD}Proceed with rename? (Y/N): {Colors.ENDC}").strip().upper()
        
        if confirm == 'Y':
            print_colored("\nExecuting rename...\n", Colors.OKCYAN)
            success, errors = rename_files(new_names, current_dir)
            
            # Final statistics
            print_colored("\n" + "="*80, Colors.HEADER)
            print_colored("FINAL STATISTICS", Colors.HEADER + Colors.BOLD)
            print_colored("="*80, Colors.HEADER)
            print_colored(f"\n✓ Files successfully renamed: {success}", Colors.OKGREEN)
            
            if errors > 0:
                print_colored(f"✗ Errors encountered: {errors}", Colors.FAIL)
            else:
                print_colored("✓ No errors", Colors.OKGREEN)
            
            print_colored("\n" + "="*80 + "\n", Colors.HEADER)
            break
            
        elif confirm == 'N':
            print_colored("\n✓ Operation cancelled by user.", Colors.WARNING)
            sys.exit(0)
        else:
            print_colored("Invalid response. Please enter Y or N.", Colors.WARNING)


if __name__ == "__main__":
    main()
